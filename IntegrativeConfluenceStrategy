import numpy as np
import pandas as pd
import talib.abstract as ta

from freqtrade.strategy.interface import IStrategy
from freqtrade.strategy import IntParameter, DecimalParameter
from freqtrade.persistence import Trade
from datetime import datetime

###############################################################################
#                      Funções Auxiliares
###############################################################################

def calc_takeprofit_stoploss_v4(
    dataframe: pd.DataFrame,
    idx: int,
    is_long: bool,
    rr_min: float,
    atr_factor: float,
    max_stop_factor: float,
    min_stop_dist_factor: float = 0.5,
    debug: bool = False
) -> (float, float):
    """
    Exemplo de cálculo de TP e SL:
      1) Define TP primeiro com base em Bollinger (bb_upper/bb_lower),
         highs/lows recentes e fallback no ATR.
      2) Calcula SL para garantir R:R >= rr_min.
      3) Rejeita se SL for muito curto (ex.: < ATR*min_stop_dist_factor)
         ou muito longo (ex.: > ATR*max_stop_factor).

    Retorna (tp_, sl_). Se inviável, (None, None).
    """
    close_ = dataframe.at[idx, "close"]
    atr_   = dataframe.at[idx, "atr"]

    bb_upper = dataframe.at[idx, "bb_upper"]
    bb_lower = dataframe.at[idx, "bb_lower"]

    # Procurar highs/lows dos últimos N candles
    lookback_bars = 20
    recent_slice = dataframe.iloc[max(0, idx - lookback_bars): idx + 1]
    recent_high  = recent_slice["high"].max()
    recent_low   = recent_slice["low"].min()

    # Monta lista de candidatos de TP
    tp_candidates = []
    if is_long:
        # Se Bollinger superior e high recente estiverem acima do close, são candidatos
        if bb_upper > close_:
            tp_candidates.append(bb_upper)
        if recent_high > close_:
            tp_candidates.append(recent_high)
        # Fallback ATR
        tp_candidates.append(close_ + atr_factor * atr_)

        # Filtra apenas valores acima do close
        tp_candidates = [tp for tp in tp_candidates if tp > close_]
        if not tp_candidates:
            return None, None

        # TP = menor valor acima do close (alvo mais próximo)
        tp_ = min(tp_candidates)

    else:
        # SHORT
        if bb_lower < close_:
            tp_candidates.append(bb_lower)
        if recent_low < close_:
            tp_candidates.append(recent_low)
        # Fallback ATR
        tp_candidates.append(close_ - atr_factor * atr_)

        # Filtra apenas valores abaixo do close
        tp_candidates = [tp for tp in tp_candidates if tp < close_]
        if not tp_candidates:
            return None, None

        # TP = maior valor abaixo do close (alvo mais próximo)
        tp_ = max(tp_candidates)

    dist_tp = abs(tp_ - close_)
    if dist_tp < 1e-5:
        return None, None

    # Calcula SL com base em R:R
    dist_sl = dist_tp / rr_min
    if is_long:
        sl_ = close_ - dist_sl
        if sl_ >= close_:
            return None, None
        actual_stop_dist = close_ - sl_
    else:
        sl_ = close_ + dist_sl
        if sl_ <= close_:
            return None, None
        actual_stop_dist = sl_ - close_

    # Checagem do stop com ATR
    max_stop_dist = atr_ * max_stop_factor
    min_stop_dist = atr_ * min_stop_dist_factor

    if (actual_stop_dist > max_stop_dist) or (actual_stop_dist < min_stop_dist):
        return None, None

    if debug:
        print(f"[DEBUG] idx={idx}, is_long={is_long}, close={close_:.5f}, TP={tp_:.5f}, SL={sl_:.5f}")

    return (tp_, sl_)


###############################################################################
#                  Classe Principal IntegrativeConfluenceStrategy
###############################################################################

class IntegrativeConfluenceStrategy(IStrategy):
    """
    Estratégia que usa:
      - Bollinger Bands para reversões (close < bb_lower => LONG; close > bb_upper => SHORT).
      - RSI, ADX e Volume como filtros.
      - Calcula TP e SL via calc_takeprofit_stoploss_v4() com R:R >= rr_min.
      - custom_stoploss() para time-based stop e encerramento por STOP ou TP.

    Se estiver gerando poucos trades ou trades longuíssimos:
     - Verifique 'use_custom_stoploss': true no config.
     - Ajuste 'timerange' com alguns dias extras ao final.
     - Diminua a max_trade_duration_in_hours.
     - Relaxar cond_bb / rsi / adx / volume se quiser mais trades.
    """

    INTERFACE_VERSION = 3
    can_short = True
    timeframe = "1h"

    # Desativamos ROI/trailing => confiamos no custom_stoploss
    minimal_roi = {"0": 1e10}
    stoploss    = -0.99
    trailing_stop = False

    # Bollinger
    bb_period = IntParameter(10, 30, default=20, space="buy")
    bb_dev    = DecimalParameter(1.5, 3.0, default=2.0, space="buy")

    # RSI
    rsi_period = IntParameter(10, 25, default=14, space="buy")
    rsi_lower  = IntParameter(20, 35, default=30, space="buy")
    rsi_upper  = IntParameter(65, 80, default=70, space="buy")

    # ADX
    adx_thr = IntParameter(15, 35, default=25, space="buy")

    # Volume
    vol_ma_len = IntParameter(10, 48, default=24, space="buy")
    vol_mult   = DecimalParameter(1.0, 2.0, default=1.2, space="buy")

    # ATR p/ fallback e checks
    atr_period = IntParameter(10, 20, default=14, space="buy")

    # R:R e distâncias
    rr_min = DecimalParameter(1.5, 3.0, default=1.8, space="buy")
    atr_factor      = DecimalParameter(1.0, 3.0, default=2.0, space="buy")
    max_stop_factor = DecimalParameter(2.0, 5.0, default=3.0, space="buy")
    min_stop_factor = DecimalParameter(0.3, 1.0, default=0.5, space="buy")

    # Tempo máximo do trade (horas)
    max_trade_duration_in_hours = IntParameter(12, 240, default=72, space="buy")

    def populate_indicators(self, df: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """
        Calcula Bollinger, RSI, ADX, Volume e ATR.
        """
        # Bollinger (apenas série 'close')
        upper_bb, mid_bb, lower_bb = ta.BBANDS(
            df["close"],
            timeperiod=self.bb_period.value,
            nbdevup=self.bb_dev.value,
            nbdevdn=self.bb_dev.value,
            matype=0
        )
        df["bb_upper"] = upper_bb.astype(float)
        df["bb_mid"]   = mid_bb.astype(float)
        df["bb_lower"] = lower_bb.astype(float)

        # RSI
        df["rsi"] = ta.RSI(df["close"], timeperiod=self.rsi_period.value)

        # ADX
        df["adx"] = ta.ADX(df)

        # Volume (SMA)
        df["vol_ma"] = ta.SMA(df["volume"], timeperiod=self.vol_ma_len.value)

        # ATR
        df["atr"] = ta.ATR(df, timeperiod=self.atr_period.value)

        return df

    def populate_entry_trend(self, df: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """
        Sinais de entrada e armazenamento de TP/SL no enter_tag.
        """
        df["enter_long"]  = 0
        df["enter_short"] = 0
        df["enter_tag"]   = np.nan

        cond_data = (
            ~df["bb_upper"].isna() &
            ~df["bb_lower"].isna() &
            ~df["rsi"].isna() &
            ~df["adx"].isna() &
            ~df["vol_ma"].isna() &
            ~df["atr"].isna()
        )

        # Bollinger => reversão
        cond_bb_long  = df["close"] < df["bb_lower"]
        cond_bb_short = df["close"] > df["bb_upper"]

        # RSI e ADX
        cond_rsi_long  = df["rsi"] < self.rsi_upper.value
        cond_rsi_short = df["rsi"] > self.rsi_lower.value
        cond_adx = df["adx"] > self.adx_thr.value

        # Volume
        cond_vol = df["volume"] > (df["vol_ma"] * self.vol_mult.value)

        # Combina
        cond_long = (
            cond_data &
            cond_bb_long & cond_rsi_long &
            cond_adx & cond_vol
        )
        cond_short= (
            cond_data &
            cond_bb_short & cond_rsi_short &
            cond_adx & cond_vol
        )

        long_idxs  = df.index[cond_long].tolist()
        short_idxs = df.index[cond_short].tolist()

        for idx in long_idxs:
            tp_, sl_ = calc_takeprofit_stoploss_v4(
                df, idx, is_long=True,
                rr_min=self.rr_min.value,
                atr_factor=self.atr_factor.value,
                max_stop_factor=self.max_stop_factor.value,
                min_stop_dist_factor=self.min_stop_factor.value,
                debug=False  # se quiser debug, colocar True
            )
            if tp_ is not None and sl_ is not None:
                tag = f"TP={tp_:.5f}|SL={sl_:.5f}|RR={self.rr_min.value}"
                df.at[idx, "enter_long"] = 1
                df.at[idx, "enter_tag"]  = tag

        for idx in short_idxs:
            tp_, sl_ = calc_takeprofit_stoploss_v4(
                df, idx, is_long=False,
                rr_min=self.rr_min.value,
                atr_factor=self.atr_factor.value,
                max_stop_factor=self.max_stop_factor.value,
                min_stop_dist_factor=self.min_stop_factor.value,
                debug=False
            )
            if tp_ is not None and sl_ is not None:
                tag = f"TP={tp_:.5f}|SL={sl_:.5f}|RR={self.rr_min.value}"
                df.at[idx, "enter_short"] = 1
                df.at[idx, "enter_tag"]   = tag

        return df

    def populate_exit_trend(self, df: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """
        Não usamos ROI ou trailing. Saída é controlada no custom_stoploss().
        """
        df["exit_long"]  = 0
        df["exit_short"] = 0
        return df

    def custom_stoploss(
        self,
        pair: str,
        trade: Trade,
        current_time: datetime,
        current_rate: float,
        current_profit: float,
        **kwargs
    ) -> float:
        """
        Lê do enter_tag: "TP=...|SL=...|RR=...".
        Fecha se bater STOP ou TP. Aplica time-based stop.
        """

        if not trade.enter_tag:
            return 1.0  # fallback

        try:
            parts = trade.enter_tag.split("|")
            tp_ = float(parts[0].split("=")[1])  # "TP=xxx"
            sl_ = float(parts[1].split("=")[1])  # "SL=yyy"
        except Exception:
            return 1.0

        # STOP/TP
        if trade.is_long:
            if current_rate <= sl_:
                return 0.0  # stop
            if current_rate >= tp_:
                return -0.0001  # take-profit
        else:
            # SHORT
            if current_rate >= sl_:
                return 0.0
            if current_rate <= tp_:
                return -0.0001

        # Time-based stop
        dur_hours = (current_time - trade.open_date_utc).total_seconds() / 3600.0
        if dur_hours >= self.max_trade_duration_in_hours.value:
            return -0.0001

        return 1.0

import numpy as np
import pandas as pd
import talib.abstract as ta

from freqtrade.strategy.interface import IStrategy
from freqtrade.strategy import IntParameter, DecimalParameter
from freqtrade.persistence import Trade
from datetime import datetime

##############################################################################
#                       Funções Auxiliares
##############################################################################

def pivot_low(dataframe: pd.DataFrame, idx: int, left_bars: int = 2, right_bars: int = 2) -> bool:
    """
    Verifica se o 'low' em dataframe['low'][idx] é o menor valor dentro
    de um raio de left_bars à esquerda e right_bars à direita.
    """
    if idx - left_bars < 0 or idx + right_bars >= len(dataframe):
        return False

    val = dataframe["low"].iloc[idx]
    for i in range(idx - left_bars, idx + right_bars + 1):
        if dataframe["low"].iloc[i] < val:
            return False
    return True


def pivot_high(dataframe: pd.DataFrame, idx: int, left_bars: int = 2, right_bars: int = 2) -> bool:
    """
    Verifica se o 'high' em dataframe['high'][idx] é o maior valor dentro
    de left_bars à esquerda e right_bars à direita.
    """
    if idx - left_bars < 0 or idx + right_bars >= len(dataframe):
        return False

    val = dataframe["high"].iloc[idx]
    for i in range(idx - left_bars, idx + right_bars + 1):
        if dataframe["high"].iloc[i] > val:
            return False
    return True


def calc_takeprofit_stoploss_v4(
    dataframe: pd.DataFrame,
    idx: int,
    is_long: bool,
    rr_min: float,
    atr_factor: float,
    max_stop_factor: float,
) -> (float, float):
    """
    Calcula TP e SL com base em Bollinger Bands, pivôs e fallback de ATR.
    - rr_min: relação R:R mínima desejada (ex.: 2.0 -> 1:2).
    - atr_factor: multiplica ATR para determinar fallback do TP.
    - max_stop_factor: multiplica ATR para limitar a distância máxima do SL.

    Retorna (tp, sl). Se inviável, retorna (None, None).
    """
    close_ = dataframe.at[idx, "close"]
    atr_ = dataframe.at[idx, "atr"]

    bb_upper = dataframe.at[idx, "bb_upper"]
    bb_lower = dataframe.at[idx, "bb_lower"]

    # Recupera últimos 20 candles para achar recent_high/low
    lookback_bars = 20
    recent_slice = dataframe.iloc[max(0, idx - lookback_bars) : idx + 1]
    recent_high = recent_slice["high"].max()
    recent_low = recent_slice["low"].min()

    # Monta lista de candidatos a TP
    tp_candidates = []

    if is_long:
        # Bollinger e pivô acima do close
        if bb_upper > close_:
            tp_candidates.append(bb_upper)
        if recent_high > close_:
            tp_candidates.append(recent_high)
        # Fallback ATR
        tp_candidates.append(close_ + (atr_factor * atr_))
        # Filtra apenas valores acima do preço
        tp_candidates = [tp for tp in tp_candidates if tp > close_]
        if not tp_candidates:
            return None, None

        # Pega alvo "mais próximo" acima do close
        tp_ = min(tp_candidates)
        dist_tp = tp_ - close_

        if dist_tp < 0.00001:
            return None, None

        # Calcula SL => R:R >= rr_min
        sl_ = close_ - (dist_tp / rr_min)
        if sl_ >= close_:
            return None, None

        # Limita SL se ficar muito distante
        max_stop_dist = atr_ * max_stop_factor
        if (close_ - sl_) > max_stop_dist:
            return None, None

    else:
        # SHORT
        if bb_lower < close_:
            tp_candidates.append(bb_lower)
        if recent_low < close_:
            tp_candidates.append(recent_low)
        # Fallback ATR
        tp_candidates.append(close_ - (atr_factor * atr_))
        # Filtra valores abaixo do preço
        tp_candidates = [tp for tp in tp_candidates if tp < close_]
        if not tp_candidates:
            return None, None

        # Pega alvo mais próximo abaixo do close
        tp_ = max(tp_candidates)
        dist_tp = close_ - tp_

        if dist_tp < 0.00001:
            return None, None

        # SL => R:R >= rr_min
        sl_ = close_ + (dist_tp / rr_min)
        if sl_ <= close_:
            return None, None

        max_stop_dist = atr_ * max_stop_factor
        if (sl_ - close_) > max_stop_dist:
            return None, None

    return (tp_, sl_)


##############################################################################
#                  Classe Principal IntegrativeConfluenceStrategy
##############################################################################

class IntegrativeConfluenceStrategy(IStrategy):
    """
    Estratégia de ex. que:
      - Usa Bollinger Bands (bb_upper/bb_lower), RSI, ADX, Volume e ATR.
      - Define TP e SL (R:R) usando calc_takeprofit_stoploss_v4().
      - Rejeita trades se R:R não for atingido ou se SL ficar inviável.
      - Time-based stop via custom_stoploss.

    Se estiver gerando poucos trades, considere:
     - relaxar cond_bb (ex.: close < bb_mid),
     - reduzir self.bb_dev,
     - baixar self.adx_thr,
     - etc.
    """

    INTERFACE_VERSION = 3
    can_short = True
    timeframe = "1h"

    # ROI e trailing => placeholders (não usado)
    minimal_roi = {"0": 1_000_000}
    stoploss = -0.99
    trailing_stop = False

    # ------------------
    # Parâmetros Bollinger
    bb_period = IntParameter(10, 30, default=20, space="buy")
    bb_dev = DecimalParameter(1.5, 3.0, default=2.0, space="buy")

    # RSI
    rsi_period = IntParameter(10, 25, default=14, space="buy")
    rsi_lower = IntParameter(20, 35, default=30, space="buy")
    rsi_upper = IntParameter(65, 80, default=70, space="buy")

    # ADX
    adx_thr = IntParameter(15, 35, default=25, space="buy")

    # Volume
    vol_ma_len = IntParameter(10, 48, default=24, space="buy")
    vol_mult = DecimalParameter(1.0, 2.0, default=1.2, space="buy")

    # ATR
    atr_period = IntParameter(10, 20, default=14, space="buy")

    # R:R Dinamico
    rr_min = DecimalParameter(1.5, 3.0, default=2.0, space="buy")
    atr_factor = DecimalParameter(1.0, 3.0, default=2.0, space="buy")
    max_stop_factor = DecimalParameter(2.0, 4.0, default=3.0, space="buy")

    # (opcional) se quiser pivot_lookback, embora não estejamos usando pivots nesse ex.
    pivot_lookback = IntParameter(2, 4, default=2, space="buy")

    # Tempo max do trade em horas
    max_trade_duration_in_hours = IntParameter(24, 240, default=72, space="buy")

    # --------------
    # populate_indicators
    def populate_indicators(self, df: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """
        Calcula Bollinger, RSI, ADX, Volume (SMA), ATR, etc.
        Necessário passar df["close"] a ta.BBANDS().
        """

        # Bollinger
        bbp = self.bb_period.value
        bbdev = self.bb_dev.value

        # Importante: Chamar BBANDS com df["close"], não o df inteiro
        upper_bb, mid_bb, lower_bb = ta.BBANDS(
            df["close"],  # <--- APENAS a série de preços
            timeperiod=bbp,
            nbdevup=bbdev,
            nbdevdn=bbdev,
            matype=0,
        )
        # Converte para float
        df["bb_upper"] = upper_bb.astype(float)
        df["bb_mid"] = mid_bb.astype(float)
        df["bb_lower"] = lower_bb.astype(float)

        # RSI e ADX
        rsi_p = self.rsi_period.value
        df["rsi"] = ta.RSI(df["close"], timeperiod=rsi_p)
        df["adx"] = ta.ADX(df)

        # Volume
        vlen = self.vol_ma_len.value
        df["vol_ma"] = ta.SMA(df["volume"], timeperiod=vlen)

        # ATR
        df["atr"] = ta.ATR(df, timeperiod=self.atr_period.value)

        return df

    # --------------
    # populate_entry_trend
    def populate_entry_trend(self, df: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """
        Identifica sinais de entrada (LONG/SHORT), define TP e SL via calc_takeprofit_stoploss_v4().
        """
        df["enter_long"] = 0
        df["enter_short"] = 0
        df["enter_tag"] = np.nan

        # Verifica colunas
        cond_data = (
            ~df["bb_upper"].isna() &
            ~df["bb_lower"].isna() &
            ~df["rsi"].isna() &
            ~df["adx"].isna() &
            ~df["vol_ma"].isna() &
            ~df["atr"].isna()
        )

        # Bollinger: Exemplo => LONG se close < bb_lower, SHORT se close > bb_upper
        cond_bb_long = df["close"] < df["bb_lower"]
        cond_bb_short = df["close"] > df["bb_upper"]

        # RSI e ADX
        cond_rsi_long = df["rsi"] < self.rsi_upper.value   # ex.: RSI < 70
        cond_rsi_short= df["rsi"] > self.rsi_lower.value   # ex.: RSI > 30
        cond_adx = df["adx"] > self.adx_thr.value

        # Volume
        cond_vol = df["volume"] > (df["vol_ma"] * self.vol_mult.value)

        # Condições finais
        cond_long = cond_data & cond_bb_long & cond_rsi_long & cond_adx & cond_vol
        cond_short= cond_data & cond_bb_short& cond_rsi_short& cond_adx & cond_vol

        long_idxs = df.index[cond_long].tolist()
        short_idxs= df.index[cond_short].tolist()

        for idx in long_idxs:
            tp_, sl_ = calc_takeprofit_stoploss_v4(
                dataframe=df,
                idx=idx,
                is_long=True,
                rr_min=self.rr_min.value,
                atr_factor=self.atr_factor.value,
                max_stop_factor=self.max_stop_factor.value,
            )
            if tp_ is not None and sl_ is not None:
                tag = f"TP={tp_:.5f}|SL={sl_:.5f}|RR={self.rr_min.value}"
                df.at[idx, "enter_long"] = 1
                df.at[idx, "enter_tag"] = tag

        for idx in short_idxs:
            tp_, sl_ = calc_takeprofit_stoploss_v4(
                dataframe=df,
                idx=idx,
                is_long=False,
                rr_min=self.rr_min.value,
                atr_factor=self.atr_factor.value,
                max_stop_factor=self.max_stop_factor.value,
            )
            if tp_ is not None and sl_ is not None:
                tag = f"TP={tp_:.5f}|SL={sl_:.5f}|RR={self.rr_min.value}"
                df.at[idx, "enter_short"] = 1
                df.at[idx, "enter_tag"] = tag

        return df

    # --------------
    # populate_exit_trend
    def populate_exit_trend(self, df: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """
        Saída básica. O real controle de saída é via custom_stoploss().
        """
        df["exit_long"] = 0
        df["exit_short"] = 0
        return df

    # --------------
    # custom_stoploss
    def custom_stoploss(
        self,
        pair: str,
        trade: Trade,
        current_time: datetime,
        current_rate: float,
        current_profit: float,
        **kwargs
    ) -> float:
        """
        Lê TP/SL do enter_tag. Se atinge STOP ou TP, encerra.
        Formato do enter_tag: "TP=xxx|SL=yyy|RR=z"
        Time-based stop => se exceder max_trade_duration_in_hours.
        """
        if not trade.enter_tag:
            return 1.0

        try:
            parts = trade.enter_tag.split("|")
            # Ex.: "TP=123.45" => parts[0],  "SL=120.00" => parts[1]
            tp_val = parts[0].split("=")[1]
            sl_val = parts[1].split("=")[1]
            tp_ = float(tp_val)
            sl_ = float(sl_val)
        except Exception:
            return 1.0

        # Verifica STOP/TP
        if trade.is_long:
            if current_rate <= sl_:
                return 0.0  # stop
            if current_rate >= tp_:
                return -0.0001  # take-profit
        else:
            # SHORT
            if current_rate >= sl_:
                return 0.0
            if current_rate <= tp_:
                return -0.0001

        # Time-based stop
        opened_since = (current_time - trade.open_date_utc).total_seconds() / 3600.0
        if opened_since >= self.max_trade_duration_in_hours.value:
            return -0.0001

        return 1.0

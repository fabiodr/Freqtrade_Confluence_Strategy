import numpy as np
import pandas as pd
import talib.abstract as ta

from freqtrade.strategy.interface import IStrategy
from freqtrade.strategy import IntParameter, DecimalParameter
from freqtrade.persistence import Trade
from datetime import datetime, timedelta

##############################################################################
#                       Funções Auxiliares
##############################################################################

def pivot_low(dataframe: pd.DataFrame, idx: int, left_bars: int = 2, right_bars: int = 2) -> bool:
    """
    Verifica se o 'low' em dataframe['low'][idx] é o menor valor dentro de um
    raio de left_bars para a esquerda e right_bars para a direita.
    """
    if idx - left_bars < 0 or idx + right_bars >= len(dataframe):
        return False

    val = dataframe["low"].iloc[idx]
    for i in range(idx - left_bars, idx + right_bars + 1):
        if dataframe["low"].iloc[i] < val:
            return False
    return True


def pivot_high(dataframe: pd.DataFrame, idx: int, left_bars: int = 2, right_bars: int = 2) -> bool:
    """
    Verifica se o 'high' em dataframe['high'][idx] é o maior valor dentro de um
    raio de left_bars para a esquerda e right_bars para a direita.
    """
    if idx - left_bars < 0 or idx + right_bars >= len(dataframe):
        return False

    val = dataframe["high"].iloc[idx]
    for i in range(idx - left_bars, idx + right_bars + 1):
        if dataframe["high"].iloc[i] > val:
            return False
    return True


def calc_takeprofit_stoploss_v4(
    dataframe: pd.DataFrame,
    idx: int,
    is_long: bool,
    rr_min: float,
    atr_factor: float,
    max_stop_factor: float,
) -> (float, float):
    """
    Calcula TP e SL com base em Bollinger Bands, pivôs e fallback de ATR.
    - rr_min: relação R:R mínima desejada (ex.: 2.0 -> 1:2).
    - atr_factor: multiplica ATR para determinar um fallback do TP.
    - max_stop_factor: multiplica ATR para limitar a distância máxima do SL.
    Retorna (tp, sl). Se inviável, retorna (None, None).
    """

    close_ = dataframe.at[idx, "close"]
    atr_ = dataframe.at[idx, "atr"]

    bb_upper = dataframe.at[idx, "bb_upper"]
    bb_lower = dataframe.at[idx, "bb_lower"]

    # Recupera últimos 20 candles para achar recent_high/low
    lookback_bars = 20
    recent_slice = dataframe.iloc[max(0, idx - lookback_bars) : idx + 1]
    recent_high = recent_slice["high"].max()
    recent_low = recent_slice["low"].min()

    # Monta lista de candidatos a TP
    tp_candidates = []

    if is_long:
        # Bollinger e pivôs acima do close
        if bb_upper > close_:
            tp_candidates.append(bb_upper)
        if recent_high > close_:
            tp_candidates.append(recent_high)
        # ATR fallback
        tp_candidates.append(close_ + (atr_factor * atr_))

        # Filtra apenas valores acima do preço
        tp_candidates = [tp for tp in tp_candidates if tp > close_]

        if not tp_candidates:
            return None, None

        # Pega o alvo "mais próximo" acima do close (min)
        tp_ = min(tp_candidates)

        # Distância do close até o TP
        dist_tp = tp_ - close_
        if dist_tp < 0.00001:
            return None, None

        # SL para manter R:R >= rr_min
        sl_ = close_ - (dist_tp / rr_min)
        if sl_ >= close_:
            return None, None

        # Limita SL se ficar muito distante
        max_stop_dist = atr_ * max_stop_factor
        if (close_ - sl_) > max_stop_dist:
            return None, None

    else:
        # SHORT
        if bb_lower < close_:
            tp_candidates.append(bb_lower)
        if recent_low < close_:
            tp_candidates.append(recent_low)
        tp_candidates.append(close_ - (atr_factor * atr_))

        # Filtra apenas valores abaixo do preço
        tp_candidates = [tp for tp in tp_candidates if tp < close_]

        if not tp_candidates:
            return None, None

        # Pega alvo mais próximo abaixo do close
        tp_ = max(tp_candidates)

        dist_tp = close_ - tp_
        if dist_tp < 0.00001:
            return None, None

        # SL => R:R >= rr_min
        sl_ = close_ + (dist_tp / rr_min)
        if sl_ <= close_:
            return None, None

        max_stop_dist = atr_ * max_stop_factor
        if (sl_ - close_) > max_stop_dist:
            return None, None

    return (tp_, sl_)


##############################################################################
#                    Classe de Estratégia Principal
##############################################################################

class IntegrativeConfluenceStrategy(IStrategy):
    """
    Estratégia de ex. que:
      - Usa Bollinger (bb_upper/bb_lower) + RSI + ADX + Volume + ATR.
      - Define TP e SL (R:R) usando calc_takeprofit_stoploss_v4().
      - Rejeita trades se R:R não for atingido ou se SL ficar inviável.
      - Time-based stop via custom_stoploss.
    """

    INTERFACE_VERSION = 3
    can_short = True
    timeframe = "1h"

    # ROI/Trailing => placeholders
    minimal_roi = {"0": 1_000_000}
    stoploss = -0.99
    trailing_stop = False

    # ------------------
    # Parâmetros Bollinger
    bb_period = IntParameter(10, 30, default=20, space="buy")
    bb_dev = DecimalParameter(1.5, 3.0, default=2.0, space="buy")

    # RSI
    rsi_period = IntParameter(10, 25, default=14, space="buy")
    rsi_lower = IntParameter(20, 35, default=30, space="buy")
    rsi_upper = IntParameter(65, 80, default=70, space="buy")

    # ADX
    adx_thr = IntParameter(15, 35, default=25, space="buy")

    # Volume
    vol_ma_len = IntParameter(10, 48, default=24, space="buy")
    vol_mult = DecimalParameter(1.0, 2.0, default=1.2, space="buy")

    # ATR
    atr_period = IntParameter(10, 20, default=14, space="buy")

    # R:R Dinamico
    rr_min = DecimalParameter(1.5, 3.0, default=2.0, space="buy")
    atr_factor = DecimalParameter(1.0, 3.0, default=2.0, space="buy")
    max_stop_factor = DecimalParameter(2.0, 4.0, default=3.0, space="buy")

    # Ex.: pivot_lookback => se for pivot (opcional), neste caso não o utilizamos diretamente
    pivot_lookback = IntParameter(2, 4, default=2, space="buy")

    # Duracao max do trade
    max_trade_duration_in_hours = IntParameter(24, 240, default=72, space="buy")

    # --------------
    # populate_indicators
    def populate_indicators(self, df: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """
        Calcula Bollinger, RSI, ADX, Volume (SMA) e ATR.
        """
        # Bollinger
        bbp = self.bb_period.value
        bbdev = self.bb_dev.value
        upper_bb, mid_bb, lower_bb = ta.BBANDS(
            df, timeperiod=bbp, nbdevup=bbdev, nbdevdn=bbdev, matype=0
        )
        df["bb_upper"] = upper_bb.astype(float)
        df["bb_mid"] = mid_bb.astype(float)
        df["bb_lower"] = lower_bb.astype(float)

        # RSI e ADX
        rsi_p = self.rsi_period.value
        df["rsi"] = ta.RSI(df, timeperiod=rsi_p)
        df["adx"] = ta.ADX(df)

        # Volume
        vlen = self.vol_ma_len.value
        df["vol_ma"] = ta.SMA(df["volume"], timeperiod=vlen)

        # ATR
        df["atr"] = ta.ATR(df, timeperiod=self.atr_period.value)

        return df

    # --------------
    # populate_entry_trend
    def populate_entry_trend(self, df: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        df["enter_long"] = 0
        df["enter_short"] = 0
        df["enter_tag"] = np.nan

        cond_data = (
            ~df["bb_upper"].isna() &
            ~df["bb_lower"].isna() &
            ~df["rsi"].isna() &
            ~df["adx"].isna() &
            ~df["vol_ma"].isna() &
            ~df["atr"].isna()
        )

        # Exemplo de cond Bollinger
        cond_bb_long = df["close"] < df["bb_lower"]  # reversão em banda inferior
        cond_bb_short= df["close"] > df["bb_upper"]  # reversão em banda superior

        # RSI + ADX
        cond_rsi_long = df["rsi"] < self.rsi_upper.value
        cond_rsi_short= df["rsi"] > self.rsi_lower.value

        cond_adx = df["adx"] > self.adx_thr.value

        # Volume
        cond_vol = df["volume"] > (df["vol_ma"] * self.vol_mult.value)

        # Cond Finais
        cond_long = cond_data & cond_vol & cond_adx & cond_rsi_long & cond_bb_long
        cond_short= cond_data & cond_vol & cond_adx & cond_rsi_short & cond_bb_short

        long_idxs = df.index[cond_long].tolist()
        short_idxs= df.index[cond_short].tolist()

        for idx in long_idxs:
            tp_, sl_ = calc_takeprofit_stoploss_v4(
                dataframe=df,
                idx=idx,
                is_long=True,
                rr_min=self.rr_min.value,
                atr_factor=self.atr_factor.value,
                max_stop_factor=self.max_stop_factor.value,
            )
            if tp_ is not None and sl_ is not None:
                tag = f"TP={tp_:.5f}|SL={sl_:.5f}|RR={self.rr_min.value}"
                df.at[idx, "enter_long"] = 1
                df.at[idx, "enter_tag"] = tag

        for idx in short_idxs:
            tp_, sl_ = calc_takeprofit_stoploss_v4(
                dataframe=df,
                idx=idx,
                is_long=False,
                rr_min=self.rr_min.value,
                atr_factor=self.atr_factor.value,
                max_stop_factor=self.max_stop_factor.value,
            )
            if tp_ is not None and sl_ is not None:
                tag = f"TP={tp_:.5f}|SL={sl_:.5f}|RR={self.rr_min.value}"
                df.at[idx, "enter_short"] = 1
                df.at[idx, "enter_tag"] = tag

        return df

    # --------------
    # populate_exit_trend
    def populate_exit_trend(self, df: pd.DataFrame, metadata: dict) -> pd.DataFrame:
        """
        Saída genérica. A maior parte do controle está em custom_stoploss().
        """
        df["exit_long"] = 0
        df["exit_short"] = 0
        return df

    # --------------
    # custom_stoploss
    def custom_stoploss(
        self,
        pair: str,
        trade: Trade,
        current_time: datetime,
        current_rate: float,
        current_profit: float,
        **kwargs
    ) -> float:
        """
        Lê TP/SL do enter_tag. Se atinge, encerra. Aplica time-based stop.
        Formato: "TP=xxx|SL=yyy|RR=z"
        """
        if not trade.enter_tag:
            return 1.0

        try:
            parts = trade.enter_tag.split("|")
            tp_str = parts[0].split("=")[1]
            sl_str = parts[1].split("=")[1]
            tp_ = float(tp_str)
            sl_ = float(sl_str)
        except Exception:
            return 1.0

        if trade.is_long:
            if current_rate <= sl_:
                return 0.0  # STOP
            if current_rate >= tp_:
                return -0.0001  # TAKE PROFIT
        else:
            # SHORT
            if current_rate >= sl_:
                return 0.0
            if current_rate <= tp_:
                return -0.0001

        # Time-based
        trade_dur = (current_time - trade.open_date_utc)
        dur_hours = trade_dur.total_seconds() / 3600.0
        if dur_hours >= self.max_trade_duration_in_hours.value:
            return -0.0001

        return 1.0
